
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `SectionCompletion` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model SectionCompletion
 * 
 */
export type SectionCompletionModel = runtime.Types.Result.DefaultSelection<Prisma.$SectionCompletionPayload>

export type AggregateSectionCompletion = {
  _count: SectionCompletionCountAggregateOutputType | null
  _min: SectionCompletionMinAggregateOutputType | null
  _max: SectionCompletionMaxAggregateOutputType | null
}

export type SectionCompletionMinAggregateOutputType = {
  id: string | null
  userId: string | null
  sectionId: string | null
  tenantId: string | null
  completedAt: Date | null
}

export type SectionCompletionMaxAggregateOutputType = {
  id: string | null
  userId: string | null
  sectionId: string | null
  tenantId: string | null
  completedAt: Date | null
}

export type SectionCompletionCountAggregateOutputType = {
  id: number
  userId: number
  sectionId: number
  tenantId: number
  completedAt: number
  _all: number
}


export type SectionCompletionMinAggregateInputType = {
  id?: true
  userId?: true
  sectionId?: true
  tenantId?: true
  completedAt?: true
}

export type SectionCompletionMaxAggregateInputType = {
  id?: true
  userId?: true
  sectionId?: true
  tenantId?: true
  completedAt?: true
}

export type SectionCompletionCountAggregateInputType = {
  id?: true
  userId?: true
  sectionId?: true
  tenantId?: true
  completedAt?: true
  _all?: true
}

export type SectionCompletionAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which SectionCompletion to aggregate.
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SectionCompletions to fetch.
   */
  orderBy?: Prisma.SectionCompletionOrderByWithRelationInput | Prisma.SectionCompletionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.SectionCompletionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SectionCompletions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SectionCompletions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned SectionCompletions
  **/
  _count?: true | SectionCompletionCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: SectionCompletionMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: SectionCompletionMaxAggregateInputType
}

export type GetSectionCompletionAggregateType<T extends SectionCompletionAggregateArgs> = {
      [P in keyof T & keyof AggregateSectionCompletion]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateSectionCompletion[P]>
    : Prisma.GetScalarType<T[P], AggregateSectionCompletion[P]>
}




export type SectionCompletionGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.SectionCompletionWhereInput
  orderBy?: Prisma.SectionCompletionOrderByWithAggregationInput | Prisma.SectionCompletionOrderByWithAggregationInput[]
  by: Prisma.SectionCompletionScalarFieldEnum[] | Prisma.SectionCompletionScalarFieldEnum
  having?: Prisma.SectionCompletionScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: SectionCompletionCountAggregateInputType | true
  _min?: SectionCompletionMinAggregateInputType
  _max?: SectionCompletionMaxAggregateInputType
}

export type SectionCompletionGroupByOutputType = {
  id: string
  userId: string
  sectionId: string
  tenantId: string
  completedAt: Date
  _count: SectionCompletionCountAggregateOutputType | null
  _min: SectionCompletionMinAggregateOutputType | null
  _max: SectionCompletionMaxAggregateOutputType | null
}

type GetSectionCompletionGroupByPayload<T extends SectionCompletionGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<SectionCompletionGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof SectionCompletionGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], SectionCompletionGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], SectionCompletionGroupByOutputType[P]>
      }
    >
  >



export type SectionCompletionWhereInput = {
  AND?: Prisma.SectionCompletionWhereInput | Prisma.SectionCompletionWhereInput[]
  OR?: Prisma.SectionCompletionWhereInput[]
  NOT?: Prisma.SectionCompletionWhereInput | Prisma.SectionCompletionWhereInput[]
  id?: Prisma.StringFilter<"SectionCompletion"> | string
  userId?: Prisma.StringFilter<"SectionCompletion"> | string
  sectionId?: Prisma.StringFilter<"SectionCompletion"> | string
  tenantId?: Prisma.StringFilter<"SectionCompletion"> | string
  completedAt?: Prisma.DateTimeFilter<"SectionCompletion"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  section?: Prisma.XOR<Prisma.SectionScalarRelationFilter, Prisma.SectionWhereInput>
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
}

export type SectionCompletionOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  sectionId?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  section?: Prisma.SectionOrderByWithRelationInput
  tenant?: Prisma.TenantOrderByWithRelationInput
}

export type SectionCompletionWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  userId_sectionId?: Prisma.SectionCompletionUserIdSectionIdCompoundUniqueInput
  AND?: Prisma.SectionCompletionWhereInput | Prisma.SectionCompletionWhereInput[]
  OR?: Prisma.SectionCompletionWhereInput[]
  NOT?: Prisma.SectionCompletionWhereInput | Prisma.SectionCompletionWhereInput[]
  userId?: Prisma.StringFilter<"SectionCompletion"> | string
  sectionId?: Prisma.StringFilter<"SectionCompletion"> | string
  tenantId?: Prisma.StringFilter<"SectionCompletion"> | string
  completedAt?: Prisma.DateTimeFilter<"SectionCompletion"> | Date | string
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  section?: Prisma.XOR<Prisma.SectionScalarRelationFilter, Prisma.SectionWhereInput>
  tenant?: Prisma.XOR<Prisma.TenantScalarRelationFilter, Prisma.TenantWhereInput>
}, "id" | "userId_sectionId">

export type SectionCompletionOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  sectionId?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
  _count?: Prisma.SectionCompletionCountOrderByAggregateInput
  _max?: Prisma.SectionCompletionMaxOrderByAggregateInput
  _min?: Prisma.SectionCompletionMinOrderByAggregateInput
}

export type SectionCompletionScalarWhereWithAggregatesInput = {
  AND?: Prisma.SectionCompletionScalarWhereWithAggregatesInput | Prisma.SectionCompletionScalarWhereWithAggregatesInput[]
  OR?: Prisma.SectionCompletionScalarWhereWithAggregatesInput[]
  NOT?: Prisma.SectionCompletionScalarWhereWithAggregatesInput | Prisma.SectionCompletionScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"SectionCompletion"> | string
  userId?: Prisma.StringWithAggregatesFilter<"SectionCompletion"> | string
  sectionId?: Prisma.StringWithAggregatesFilter<"SectionCompletion"> | string
  tenantId?: Prisma.StringWithAggregatesFilter<"SectionCompletion"> | string
  completedAt?: Prisma.DateTimeWithAggregatesFilter<"SectionCompletion"> | Date | string
}

export type SectionCompletionCreateInput = {
  id?: string
  completedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutSectionCompletionsInput
  section: Prisma.SectionCreateNestedOneWithoutCompletionsInput
  tenant: Prisma.TenantCreateNestedOneWithoutSectionCompletionsInput
}

export type SectionCompletionUncheckedCreateInput = {
  id?: string
  userId: string
  sectionId: string
  tenantId: string
  completedAt?: Date | string
}

export type SectionCompletionUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutSectionCompletionsNestedInput
  section?: Prisma.SectionUpdateOneRequiredWithoutCompletionsNestedInput
  tenant?: Prisma.TenantUpdateOneRequiredWithoutSectionCompletionsNestedInput
}

export type SectionCompletionUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  sectionId?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionCreateManyInput = {
  id?: string
  userId: string
  sectionId: string
  tenantId: string
  completedAt?: Date | string
}

export type SectionCompletionUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  sectionId?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionListRelationFilter = {
  every?: Prisma.SectionCompletionWhereInput
  some?: Prisma.SectionCompletionWhereInput
  none?: Prisma.SectionCompletionWhereInput
}

export type SectionCompletionOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type SectionCompletionUserIdSectionIdCompoundUniqueInput = {
  userId: string
  sectionId: string
}

export type SectionCompletionCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  sectionId?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
}

export type SectionCompletionMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  sectionId?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
}

export type SectionCompletionMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  sectionId?: Prisma.SortOrder
  tenantId?: Prisma.SortOrder
  completedAt?: Prisma.SortOrder
}

export type SectionCompletionCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutTenantInput, Prisma.SectionCompletionUncheckedCreateWithoutTenantInput> | Prisma.SectionCompletionCreateWithoutTenantInput[] | Prisma.SectionCompletionUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutTenantInput | Prisma.SectionCompletionCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.SectionCompletionCreateManyTenantInputEnvelope
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
}

export type SectionCompletionUncheckedCreateNestedManyWithoutTenantInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutTenantInput, Prisma.SectionCompletionUncheckedCreateWithoutTenantInput> | Prisma.SectionCompletionCreateWithoutTenantInput[] | Prisma.SectionCompletionUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutTenantInput | Prisma.SectionCompletionCreateOrConnectWithoutTenantInput[]
  createMany?: Prisma.SectionCompletionCreateManyTenantInputEnvelope
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
}

export type SectionCompletionUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutTenantInput, Prisma.SectionCompletionUncheckedCreateWithoutTenantInput> | Prisma.SectionCompletionCreateWithoutTenantInput[] | Prisma.SectionCompletionUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutTenantInput | Prisma.SectionCompletionCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.SectionCompletionUpsertWithWhereUniqueWithoutTenantInput | Prisma.SectionCompletionUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.SectionCompletionCreateManyTenantInputEnvelope
  set?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  disconnect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  delete?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  update?: Prisma.SectionCompletionUpdateWithWhereUniqueWithoutTenantInput | Prisma.SectionCompletionUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.SectionCompletionUpdateManyWithWhereWithoutTenantInput | Prisma.SectionCompletionUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
}

export type SectionCompletionUncheckedUpdateManyWithoutTenantNestedInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutTenantInput, Prisma.SectionCompletionUncheckedCreateWithoutTenantInput> | Prisma.SectionCompletionCreateWithoutTenantInput[] | Prisma.SectionCompletionUncheckedCreateWithoutTenantInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutTenantInput | Prisma.SectionCompletionCreateOrConnectWithoutTenantInput[]
  upsert?: Prisma.SectionCompletionUpsertWithWhereUniqueWithoutTenantInput | Prisma.SectionCompletionUpsertWithWhereUniqueWithoutTenantInput[]
  createMany?: Prisma.SectionCompletionCreateManyTenantInputEnvelope
  set?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  disconnect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  delete?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  update?: Prisma.SectionCompletionUpdateWithWhereUniqueWithoutTenantInput | Prisma.SectionCompletionUpdateWithWhereUniqueWithoutTenantInput[]
  updateMany?: Prisma.SectionCompletionUpdateManyWithWhereWithoutTenantInput | Prisma.SectionCompletionUpdateManyWithWhereWithoutTenantInput[]
  deleteMany?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
}

export type SectionCompletionCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutUserInput, Prisma.SectionCompletionUncheckedCreateWithoutUserInput> | Prisma.SectionCompletionCreateWithoutUserInput[] | Prisma.SectionCompletionUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutUserInput | Prisma.SectionCompletionCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.SectionCompletionCreateManyUserInputEnvelope
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
}

export type SectionCompletionUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutUserInput, Prisma.SectionCompletionUncheckedCreateWithoutUserInput> | Prisma.SectionCompletionCreateWithoutUserInput[] | Prisma.SectionCompletionUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutUserInput | Prisma.SectionCompletionCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.SectionCompletionCreateManyUserInputEnvelope
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
}

export type SectionCompletionUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutUserInput, Prisma.SectionCompletionUncheckedCreateWithoutUserInput> | Prisma.SectionCompletionCreateWithoutUserInput[] | Prisma.SectionCompletionUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutUserInput | Prisma.SectionCompletionCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.SectionCompletionUpsertWithWhereUniqueWithoutUserInput | Prisma.SectionCompletionUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.SectionCompletionCreateManyUserInputEnvelope
  set?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  disconnect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  delete?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  update?: Prisma.SectionCompletionUpdateWithWhereUniqueWithoutUserInput | Prisma.SectionCompletionUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.SectionCompletionUpdateManyWithWhereWithoutUserInput | Prisma.SectionCompletionUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
}

export type SectionCompletionUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutUserInput, Prisma.SectionCompletionUncheckedCreateWithoutUserInput> | Prisma.SectionCompletionCreateWithoutUserInput[] | Prisma.SectionCompletionUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutUserInput | Prisma.SectionCompletionCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.SectionCompletionUpsertWithWhereUniqueWithoutUserInput | Prisma.SectionCompletionUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.SectionCompletionCreateManyUserInputEnvelope
  set?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  disconnect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  delete?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  update?: Prisma.SectionCompletionUpdateWithWhereUniqueWithoutUserInput | Prisma.SectionCompletionUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.SectionCompletionUpdateManyWithWhereWithoutUserInput | Prisma.SectionCompletionUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
}

export type SectionCompletionCreateNestedManyWithoutSectionInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutSectionInput, Prisma.SectionCompletionUncheckedCreateWithoutSectionInput> | Prisma.SectionCompletionCreateWithoutSectionInput[] | Prisma.SectionCompletionUncheckedCreateWithoutSectionInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutSectionInput | Prisma.SectionCompletionCreateOrConnectWithoutSectionInput[]
  createMany?: Prisma.SectionCompletionCreateManySectionInputEnvelope
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
}

export type SectionCompletionUncheckedCreateNestedManyWithoutSectionInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutSectionInput, Prisma.SectionCompletionUncheckedCreateWithoutSectionInput> | Prisma.SectionCompletionCreateWithoutSectionInput[] | Prisma.SectionCompletionUncheckedCreateWithoutSectionInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutSectionInput | Prisma.SectionCompletionCreateOrConnectWithoutSectionInput[]
  createMany?: Prisma.SectionCompletionCreateManySectionInputEnvelope
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
}

export type SectionCompletionUpdateManyWithoutSectionNestedInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutSectionInput, Prisma.SectionCompletionUncheckedCreateWithoutSectionInput> | Prisma.SectionCompletionCreateWithoutSectionInput[] | Prisma.SectionCompletionUncheckedCreateWithoutSectionInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutSectionInput | Prisma.SectionCompletionCreateOrConnectWithoutSectionInput[]
  upsert?: Prisma.SectionCompletionUpsertWithWhereUniqueWithoutSectionInput | Prisma.SectionCompletionUpsertWithWhereUniqueWithoutSectionInput[]
  createMany?: Prisma.SectionCompletionCreateManySectionInputEnvelope
  set?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  disconnect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  delete?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  update?: Prisma.SectionCompletionUpdateWithWhereUniqueWithoutSectionInput | Prisma.SectionCompletionUpdateWithWhereUniqueWithoutSectionInput[]
  updateMany?: Prisma.SectionCompletionUpdateManyWithWhereWithoutSectionInput | Prisma.SectionCompletionUpdateManyWithWhereWithoutSectionInput[]
  deleteMany?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
}

export type SectionCompletionUncheckedUpdateManyWithoutSectionNestedInput = {
  create?: Prisma.XOR<Prisma.SectionCompletionCreateWithoutSectionInput, Prisma.SectionCompletionUncheckedCreateWithoutSectionInput> | Prisma.SectionCompletionCreateWithoutSectionInput[] | Prisma.SectionCompletionUncheckedCreateWithoutSectionInput[]
  connectOrCreate?: Prisma.SectionCompletionCreateOrConnectWithoutSectionInput | Prisma.SectionCompletionCreateOrConnectWithoutSectionInput[]
  upsert?: Prisma.SectionCompletionUpsertWithWhereUniqueWithoutSectionInput | Prisma.SectionCompletionUpsertWithWhereUniqueWithoutSectionInput[]
  createMany?: Prisma.SectionCompletionCreateManySectionInputEnvelope
  set?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  disconnect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  delete?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  connect?: Prisma.SectionCompletionWhereUniqueInput | Prisma.SectionCompletionWhereUniqueInput[]
  update?: Prisma.SectionCompletionUpdateWithWhereUniqueWithoutSectionInput | Prisma.SectionCompletionUpdateWithWhereUniqueWithoutSectionInput[]
  updateMany?: Prisma.SectionCompletionUpdateManyWithWhereWithoutSectionInput | Prisma.SectionCompletionUpdateManyWithWhereWithoutSectionInput[]
  deleteMany?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
}

export type SectionCompletionCreateWithoutTenantInput = {
  id?: string
  completedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutSectionCompletionsInput
  section: Prisma.SectionCreateNestedOneWithoutCompletionsInput
}

export type SectionCompletionUncheckedCreateWithoutTenantInput = {
  id?: string
  userId: string
  sectionId: string
  completedAt?: Date | string
}

export type SectionCompletionCreateOrConnectWithoutTenantInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  create: Prisma.XOR<Prisma.SectionCompletionCreateWithoutTenantInput, Prisma.SectionCompletionUncheckedCreateWithoutTenantInput>
}

export type SectionCompletionCreateManyTenantInputEnvelope = {
  data: Prisma.SectionCompletionCreateManyTenantInput | Prisma.SectionCompletionCreateManyTenantInput[]
  skipDuplicates?: boolean
}

export type SectionCompletionUpsertWithWhereUniqueWithoutTenantInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  update: Prisma.XOR<Prisma.SectionCompletionUpdateWithoutTenantInput, Prisma.SectionCompletionUncheckedUpdateWithoutTenantInput>
  create: Prisma.XOR<Prisma.SectionCompletionCreateWithoutTenantInput, Prisma.SectionCompletionUncheckedCreateWithoutTenantInput>
}

export type SectionCompletionUpdateWithWhereUniqueWithoutTenantInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  data: Prisma.XOR<Prisma.SectionCompletionUpdateWithoutTenantInput, Prisma.SectionCompletionUncheckedUpdateWithoutTenantInput>
}

export type SectionCompletionUpdateManyWithWhereWithoutTenantInput = {
  where: Prisma.SectionCompletionScalarWhereInput
  data: Prisma.XOR<Prisma.SectionCompletionUpdateManyMutationInput, Prisma.SectionCompletionUncheckedUpdateManyWithoutTenantInput>
}

export type SectionCompletionScalarWhereInput = {
  AND?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
  OR?: Prisma.SectionCompletionScalarWhereInput[]
  NOT?: Prisma.SectionCompletionScalarWhereInput | Prisma.SectionCompletionScalarWhereInput[]
  id?: Prisma.StringFilter<"SectionCompletion"> | string
  userId?: Prisma.StringFilter<"SectionCompletion"> | string
  sectionId?: Prisma.StringFilter<"SectionCompletion"> | string
  tenantId?: Prisma.StringFilter<"SectionCompletion"> | string
  completedAt?: Prisma.DateTimeFilter<"SectionCompletion"> | Date | string
}

export type SectionCompletionCreateWithoutUserInput = {
  id?: string
  completedAt?: Date | string
  section: Prisma.SectionCreateNestedOneWithoutCompletionsInput
  tenant: Prisma.TenantCreateNestedOneWithoutSectionCompletionsInput
}

export type SectionCompletionUncheckedCreateWithoutUserInput = {
  id?: string
  sectionId: string
  tenantId: string
  completedAt?: Date | string
}

export type SectionCompletionCreateOrConnectWithoutUserInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  create: Prisma.XOR<Prisma.SectionCompletionCreateWithoutUserInput, Prisma.SectionCompletionUncheckedCreateWithoutUserInput>
}

export type SectionCompletionCreateManyUserInputEnvelope = {
  data: Prisma.SectionCompletionCreateManyUserInput | Prisma.SectionCompletionCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type SectionCompletionUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  update: Prisma.XOR<Prisma.SectionCompletionUpdateWithoutUserInput, Prisma.SectionCompletionUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.SectionCompletionCreateWithoutUserInput, Prisma.SectionCompletionUncheckedCreateWithoutUserInput>
}

export type SectionCompletionUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  data: Prisma.XOR<Prisma.SectionCompletionUpdateWithoutUserInput, Prisma.SectionCompletionUncheckedUpdateWithoutUserInput>
}

export type SectionCompletionUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.SectionCompletionScalarWhereInput
  data: Prisma.XOR<Prisma.SectionCompletionUpdateManyMutationInput, Prisma.SectionCompletionUncheckedUpdateManyWithoutUserInput>
}

export type SectionCompletionCreateWithoutSectionInput = {
  id?: string
  completedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutSectionCompletionsInput
  tenant: Prisma.TenantCreateNestedOneWithoutSectionCompletionsInput
}

export type SectionCompletionUncheckedCreateWithoutSectionInput = {
  id?: string
  userId: string
  tenantId: string
  completedAt?: Date | string
}

export type SectionCompletionCreateOrConnectWithoutSectionInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  create: Prisma.XOR<Prisma.SectionCompletionCreateWithoutSectionInput, Prisma.SectionCompletionUncheckedCreateWithoutSectionInput>
}

export type SectionCompletionCreateManySectionInputEnvelope = {
  data: Prisma.SectionCompletionCreateManySectionInput | Prisma.SectionCompletionCreateManySectionInput[]
  skipDuplicates?: boolean
}

export type SectionCompletionUpsertWithWhereUniqueWithoutSectionInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  update: Prisma.XOR<Prisma.SectionCompletionUpdateWithoutSectionInput, Prisma.SectionCompletionUncheckedUpdateWithoutSectionInput>
  create: Prisma.XOR<Prisma.SectionCompletionCreateWithoutSectionInput, Prisma.SectionCompletionUncheckedCreateWithoutSectionInput>
}

export type SectionCompletionUpdateWithWhereUniqueWithoutSectionInput = {
  where: Prisma.SectionCompletionWhereUniqueInput
  data: Prisma.XOR<Prisma.SectionCompletionUpdateWithoutSectionInput, Prisma.SectionCompletionUncheckedUpdateWithoutSectionInput>
}

export type SectionCompletionUpdateManyWithWhereWithoutSectionInput = {
  where: Prisma.SectionCompletionScalarWhereInput
  data: Prisma.XOR<Prisma.SectionCompletionUpdateManyMutationInput, Prisma.SectionCompletionUncheckedUpdateManyWithoutSectionInput>
}

export type SectionCompletionCreateManyTenantInput = {
  id?: string
  userId: string
  sectionId: string
  completedAt?: Date | string
}

export type SectionCompletionUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutSectionCompletionsNestedInput
  section?: Prisma.SectionUpdateOneRequiredWithoutCompletionsNestedInput
}

export type SectionCompletionUncheckedUpdateWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  sectionId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionUncheckedUpdateManyWithoutTenantInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  sectionId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionCreateManyUserInput = {
  id?: string
  sectionId: string
  tenantId: string
  completedAt?: Date | string
}

export type SectionCompletionUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  section?: Prisma.SectionUpdateOneRequiredWithoutCompletionsNestedInput
  tenant?: Prisma.TenantUpdateOneRequiredWithoutSectionCompletionsNestedInput
}

export type SectionCompletionUncheckedUpdateWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  sectionId?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  sectionId?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionCreateManySectionInput = {
  id?: string
  userId: string
  tenantId: string
  completedAt?: Date | string
}

export type SectionCompletionUpdateWithoutSectionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutSectionCompletionsNestedInput
  tenant?: Prisma.TenantUpdateOneRequiredWithoutSectionCompletionsNestedInput
}

export type SectionCompletionUncheckedUpdateWithoutSectionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type SectionCompletionUncheckedUpdateManyWithoutSectionInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  userId?: Prisma.StringFieldUpdateOperationsInput | string
  tenantId?: Prisma.StringFieldUpdateOperationsInput | string
  completedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type SectionCompletionSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  sectionId?: boolean
  tenantId?: boolean
  completedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  section?: boolean | Prisma.SectionDefaultArgs<ExtArgs>
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
}, ExtArgs["result"]["sectionCompletion"]>

export type SectionCompletionSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  sectionId?: boolean
  tenantId?: boolean
  completedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  section?: boolean | Prisma.SectionDefaultArgs<ExtArgs>
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
}, ExtArgs["result"]["sectionCompletion"]>

export type SectionCompletionSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  userId?: boolean
  sectionId?: boolean
  tenantId?: boolean
  completedAt?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  section?: boolean | Prisma.SectionDefaultArgs<ExtArgs>
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
}, ExtArgs["result"]["sectionCompletion"]>

export type SectionCompletionSelectScalar = {
  id?: boolean
  userId?: boolean
  sectionId?: boolean
  tenantId?: boolean
  completedAt?: boolean
}

export type SectionCompletionOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "userId" | "sectionId" | "tenantId" | "completedAt", ExtArgs["result"]["sectionCompletion"]>
export type SectionCompletionInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  section?: boolean | Prisma.SectionDefaultArgs<ExtArgs>
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
}
export type SectionCompletionIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  section?: boolean | Prisma.SectionDefaultArgs<ExtArgs>
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
}
export type SectionCompletionIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  section?: boolean | Prisma.SectionDefaultArgs<ExtArgs>
  tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>
}

export type $SectionCompletionPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "SectionCompletion"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    section: Prisma.$SectionPayload<ExtArgs>
    tenant: Prisma.$TenantPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    userId: string
    sectionId: string
    tenantId: string
    completedAt: Date
  }, ExtArgs["result"]["sectionCompletion"]>
  composites: {}
}

export type SectionCompletionGetPayload<S extends boolean | null | undefined | SectionCompletionDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload, S>

export type SectionCompletionCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<SectionCompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: SectionCompletionCountAggregateInputType | true
  }

export interface SectionCompletionDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectionCompletion'], meta: { name: 'SectionCompletion' } }
  /**
   * Find zero or one SectionCompletion that matches the filter.
   * @param {SectionCompletionFindUniqueArgs} args - Arguments to find a SectionCompletion
   * @example
   * // Get one SectionCompletion
   * const sectionCompletion = await prisma.sectionCompletion.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends SectionCompletionFindUniqueArgs>(args: Prisma.SelectSubset<T, SectionCompletionFindUniqueArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one SectionCompletion that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {SectionCompletionFindUniqueOrThrowArgs} args - Arguments to find a SectionCompletion
   * @example
   * // Get one SectionCompletion
   * const sectionCompletion = await prisma.sectionCompletion.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends SectionCompletionFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, SectionCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first SectionCompletion that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionFindFirstArgs} args - Arguments to find a SectionCompletion
   * @example
   * // Get one SectionCompletion
   * const sectionCompletion = await prisma.sectionCompletion.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends SectionCompletionFindFirstArgs>(args?: Prisma.SelectSubset<T, SectionCompletionFindFirstArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first SectionCompletion that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionFindFirstOrThrowArgs} args - Arguments to find a SectionCompletion
   * @example
   * // Get one SectionCompletion
   * const sectionCompletion = await prisma.sectionCompletion.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends SectionCompletionFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, SectionCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more SectionCompletions that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all SectionCompletions
   * const sectionCompletions = await prisma.sectionCompletion.findMany()
   * 
   * // Get first 10 SectionCompletions
   * const sectionCompletions = await prisma.sectionCompletion.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const sectionCompletionWithIdOnly = await prisma.sectionCompletion.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends SectionCompletionFindManyArgs>(args?: Prisma.SelectSubset<T, SectionCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a SectionCompletion.
   * @param {SectionCompletionCreateArgs} args - Arguments to create a SectionCompletion.
   * @example
   * // Create one SectionCompletion
   * const SectionCompletion = await prisma.sectionCompletion.create({
   *   data: {
   *     // ... data to create a SectionCompletion
   *   }
   * })
   * 
   */
  create<T extends SectionCompletionCreateArgs>(args: Prisma.SelectSubset<T, SectionCompletionCreateArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many SectionCompletions.
   * @param {SectionCompletionCreateManyArgs} args - Arguments to create many SectionCompletions.
   * @example
   * // Create many SectionCompletions
   * const sectionCompletion = await prisma.sectionCompletion.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends SectionCompletionCreateManyArgs>(args?: Prisma.SelectSubset<T, SectionCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many SectionCompletions and returns the data saved in the database.
   * @param {SectionCompletionCreateManyAndReturnArgs} args - Arguments to create many SectionCompletions.
   * @example
   * // Create many SectionCompletions
   * const sectionCompletion = await prisma.sectionCompletion.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many SectionCompletions and only return the `id`
   * const sectionCompletionWithIdOnly = await prisma.sectionCompletion.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends SectionCompletionCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, SectionCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a SectionCompletion.
   * @param {SectionCompletionDeleteArgs} args - Arguments to delete one SectionCompletion.
   * @example
   * // Delete one SectionCompletion
   * const SectionCompletion = await prisma.sectionCompletion.delete({
   *   where: {
   *     // ... filter to delete one SectionCompletion
   *   }
   * })
   * 
   */
  delete<T extends SectionCompletionDeleteArgs>(args: Prisma.SelectSubset<T, SectionCompletionDeleteArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one SectionCompletion.
   * @param {SectionCompletionUpdateArgs} args - Arguments to update one SectionCompletion.
   * @example
   * // Update one SectionCompletion
   * const sectionCompletion = await prisma.sectionCompletion.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends SectionCompletionUpdateArgs>(args: Prisma.SelectSubset<T, SectionCompletionUpdateArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more SectionCompletions.
   * @param {SectionCompletionDeleteManyArgs} args - Arguments to filter SectionCompletions to delete.
   * @example
   * // Delete a few SectionCompletions
   * const { count } = await prisma.sectionCompletion.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends SectionCompletionDeleteManyArgs>(args?: Prisma.SelectSubset<T, SectionCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more SectionCompletions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many SectionCompletions
   * const sectionCompletion = await prisma.sectionCompletion.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends SectionCompletionUpdateManyArgs>(args: Prisma.SelectSubset<T, SectionCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more SectionCompletions and returns the data updated in the database.
   * @param {SectionCompletionUpdateManyAndReturnArgs} args - Arguments to update many SectionCompletions.
   * @example
   * // Update many SectionCompletions
   * const sectionCompletion = await prisma.sectionCompletion.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more SectionCompletions and only return the `id`
   * const sectionCompletionWithIdOnly = await prisma.sectionCompletion.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends SectionCompletionUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, SectionCompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one SectionCompletion.
   * @param {SectionCompletionUpsertArgs} args - Arguments to update or create a SectionCompletion.
   * @example
   * // Update or create a SectionCompletion
   * const sectionCompletion = await prisma.sectionCompletion.upsert({
   *   create: {
   *     // ... data to create a SectionCompletion
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the SectionCompletion we want to update
   *   }
   * })
   */
  upsert<T extends SectionCompletionUpsertArgs>(args: Prisma.SelectSubset<T, SectionCompletionUpsertArgs<ExtArgs>>): Prisma.Prisma__SectionCompletionClient<runtime.Types.Result.GetResult<Prisma.$SectionCompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of SectionCompletions.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionCountArgs} args - Arguments to filter SectionCompletions to count.
   * @example
   * // Count the number of SectionCompletions
   * const count = await prisma.sectionCompletion.count({
   *   where: {
   *     // ... the filter for the SectionCompletions we want to count
   *   }
   * })
  **/
  count<T extends SectionCompletionCountArgs>(
    args?: Prisma.Subset<T, SectionCompletionCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], SectionCompletionCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a SectionCompletion.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends SectionCompletionAggregateArgs>(args: Prisma.Subset<T, SectionCompletionAggregateArgs>): Prisma.PrismaPromise<GetSectionCompletionAggregateType<T>>

  /**
   * Group by SectionCompletion.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {SectionCompletionGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends SectionCompletionGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: SectionCompletionGroupByArgs['orderBy'] }
      : { orderBy?: SectionCompletionGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, SectionCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the SectionCompletion model
 */
readonly fields: SectionCompletionFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for SectionCompletion.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__SectionCompletionClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  section<T extends Prisma.SectionDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.SectionDefaultArgs<ExtArgs>>): Prisma.Prisma__SectionClient<runtime.Types.Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  tenant<T extends Prisma.TenantDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.TenantDefaultArgs<ExtArgs>>): Prisma.Prisma__TenantClient<runtime.Types.Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the SectionCompletion model
 */
export interface SectionCompletionFieldRefs {
  readonly id: Prisma.FieldRef<"SectionCompletion", 'String'>
  readonly userId: Prisma.FieldRef<"SectionCompletion", 'String'>
  readonly sectionId: Prisma.FieldRef<"SectionCompletion", 'String'>
  readonly tenantId: Prisma.FieldRef<"SectionCompletion", 'String'>
  readonly completedAt: Prisma.FieldRef<"SectionCompletion", 'DateTime'>
}
    

// Custom InputTypes
/**
 * SectionCompletion findUnique
 */
export type SectionCompletionFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * Filter, which SectionCompletion to fetch.
   */
  where: Prisma.SectionCompletionWhereUniqueInput
}

/**
 * SectionCompletion findUniqueOrThrow
 */
export type SectionCompletionFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * Filter, which SectionCompletion to fetch.
   */
  where: Prisma.SectionCompletionWhereUniqueInput
}

/**
 * SectionCompletion findFirst
 */
export type SectionCompletionFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * Filter, which SectionCompletion to fetch.
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SectionCompletions to fetch.
   */
  orderBy?: Prisma.SectionCompletionOrderByWithRelationInput | Prisma.SectionCompletionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for SectionCompletions.
   */
  cursor?: Prisma.SectionCompletionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SectionCompletions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SectionCompletions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of SectionCompletions.
   */
  distinct?: Prisma.SectionCompletionScalarFieldEnum | Prisma.SectionCompletionScalarFieldEnum[]
}

/**
 * SectionCompletion findFirstOrThrow
 */
export type SectionCompletionFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * Filter, which SectionCompletion to fetch.
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SectionCompletions to fetch.
   */
  orderBy?: Prisma.SectionCompletionOrderByWithRelationInput | Prisma.SectionCompletionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for SectionCompletions.
   */
  cursor?: Prisma.SectionCompletionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SectionCompletions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SectionCompletions.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of SectionCompletions.
   */
  distinct?: Prisma.SectionCompletionScalarFieldEnum | Prisma.SectionCompletionScalarFieldEnum[]
}

/**
 * SectionCompletion findMany
 */
export type SectionCompletionFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * Filter, which SectionCompletions to fetch.
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of SectionCompletions to fetch.
   */
  orderBy?: Prisma.SectionCompletionOrderByWithRelationInput | Prisma.SectionCompletionOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing SectionCompletions.
   */
  cursor?: Prisma.SectionCompletionWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` SectionCompletions from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` SectionCompletions.
   */
  skip?: number
  distinct?: Prisma.SectionCompletionScalarFieldEnum | Prisma.SectionCompletionScalarFieldEnum[]
}

/**
 * SectionCompletion create
 */
export type SectionCompletionCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * The data needed to create a SectionCompletion.
   */
  data: Prisma.XOR<Prisma.SectionCompletionCreateInput, Prisma.SectionCompletionUncheckedCreateInput>
}

/**
 * SectionCompletion createMany
 */
export type SectionCompletionCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many SectionCompletions.
   */
  data: Prisma.SectionCompletionCreateManyInput | Prisma.SectionCompletionCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * SectionCompletion createManyAndReturn
 */
export type SectionCompletionCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * The data used to create many SectionCompletions.
   */
  data: Prisma.SectionCompletionCreateManyInput | Prisma.SectionCompletionCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * SectionCompletion update
 */
export type SectionCompletionUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * The data needed to update a SectionCompletion.
   */
  data: Prisma.XOR<Prisma.SectionCompletionUpdateInput, Prisma.SectionCompletionUncheckedUpdateInput>
  /**
   * Choose, which SectionCompletion to update.
   */
  where: Prisma.SectionCompletionWhereUniqueInput
}

/**
 * SectionCompletion updateMany
 */
export type SectionCompletionUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update SectionCompletions.
   */
  data: Prisma.XOR<Prisma.SectionCompletionUpdateManyMutationInput, Prisma.SectionCompletionUncheckedUpdateManyInput>
  /**
   * Filter which SectionCompletions to update
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * Limit how many SectionCompletions to update.
   */
  limit?: number
}

/**
 * SectionCompletion updateManyAndReturn
 */
export type SectionCompletionUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * The data used to update SectionCompletions.
   */
  data: Prisma.XOR<Prisma.SectionCompletionUpdateManyMutationInput, Prisma.SectionCompletionUncheckedUpdateManyInput>
  /**
   * Filter which SectionCompletions to update
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * Limit how many SectionCompletions to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * SectionCompletion upsert
 */
export type SectionCompletionUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * The filter to search for the SectionCompletion to update in case it exists.
   */
  where: Prisma.SectionCompletionWhereUniqueInput
  /**
   * In case the SectionCompletion found by the `where` argument doesn't exist, create a new SectionCompletion with this data.
   */
  create: Prisma.XOR<Prisma.SectionCompletionCreateInput, Prisma.SectionCompletionUncheckedCreateInput>
  /**
   * In case the SectionCompletion was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.SectionCompletionUpdateInput, Prisma.SectionCompletionUncheckedUpdateInput>
}

/**
 * SectionCompletion delete
 */
export type SectionCompletionDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
  /**
   * Filter which SectionCompletion to delete.
   */
  where: Prisma.SectionCompletionWhereUniqueInput
}

/**
 * SectionCompletion deleteMany
 */
export type SectionCompletionDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which SectionCompletions to delete
   */
  where?: Prisma.SectionCompletionWhereInput
  /**
   * Limit how many SectionCompletions to delete.
   */
  limit?: number
}

/**
 * SectionCompletion without action
 */
export type SectionCompletionDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the SectionCompletion
   */
  select?: Prisma.SectionCompletionSelect<ExtArgs> | null
  /**
   * Omit specific fields from the SectionCompletion
   */
  omit?: Prisma.SectionCompletionOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.SectionCompletionInclude<ExtArgs> | null
}
